{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/embed/documentLoader.js","webpack:///./src/embed/iframeSizer.js","webpack:///./src/util/closure.js","webpack:///./src/util/url.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAiD;AACP;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,sBAAsB,kBAAkB,eAAe,gBAAgB;;AAE5G;AACA;AACA,uBAAuB,eAAe,GAAG;AACzC,GAAG;AACH,0BAA0B;AAC1B;AACA;AACA;AACA,sBAAsB,cAAc,GAAG;AACvC,GAAG;AACH,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,aAAa,IAAI,aAAa;AAC/D,KAAK;AACL,iCAAiC,aAAa;AAC9C;AACA;;AAEA;AACA,eAAe,8DAAY,IAAI,mCAAmB,CAAC,YAAY,GAAG,GAAG,KAAK;AAC1E,EAAE,qEAAgB;;AAElB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjFA;AAAA;AAAA;AAAA;AAA4C;;AAErC;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,oCAAoC,gEAAU;AAC9C;AACA;;AAEO;AACP;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;AC5BA;AAAA;AAAA;AAAA;AAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;;;;;;;;;;;AC1CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,UAAU;AACtB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,OAAO,EAAE,IAAI,GAAG,0BAA0B;AAC7D;AACA;AACA;AACA;;AAEA,YAAY,IAAI,EAAE,OAAO;AACzB;;AAEA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA","file":"loader.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import { setupResizeEvent } from './iframeSizer';\nimport { queryBuilder } from '@/util/url';\n\nfunction injectIframe(url, options, container) {\n  const parts = url.split('/').slice(-2);\n  if (parts.length != 2) return;\n  if (parts[0] != 'documents') return;\n  const slugId = parts[1];\n  const slugHyphen = slugId.indexOf('-');\n  if (slugHyphen == -1) return;\n  const id = slugId.substring(0, slugHyphen);\n  const slugExtension = slugId.substring(slugHyphen + 1);\n  const slugParts = slugExtension.split('.');\n  if (slugParts.length < 1) return;\n  const slug = slugParts[0];\n\n  // Create the iframe\n  const iframe = document.createElement('iframe');\n\n  // Ported from https://github.com/documentcloud/document-viewer/blob/master/public/javascripts/DV/helpers/construction.js\n  if (options.responsive) {\n    if (!options.height) {\n      const windowHeight = window.innerHeight;\n      const toSubtract = options.responsiveOffset == null ? 100 : options.responsiveOffset;\n      options.height = windowHeight - toSubtract;\n    }\n  }\n\n  const queryParams = {};\n  let urlPostfix = '';\n  let style = 'border:solid 1px #aaa;box-sizing:border-box;position:relative;max-width:100%;max-height:100%;';\n\n  // Height option\n  if (options.height != null) {\n    style += `height:${options.height}px;`;\n  } else {\n    style += `height:100%;`;\n  }\n  // Width option\n  if (options.width != null) {\n    style += `width:${options.width}px;`;\n  } else {\n    style += `width:100%;`;\n  }\n  // Sidebar, text, and pdf options\n  if (options.sidebar != null) {\n    queryParams['sidebar'] = options.sidebar ? 1 : 0;\n  }\n  if (options.text == false) {\n    queryParams['text'] = 0;\n  }\n  if (options.pdf == false) {\n    queryParams['pdf'] = 0;\n  }\n  // Page option\n  if (options.page != null) {\n    if (options.note != null) {\n      // Note option (must have page defined)\n      urlPostfix = `#document/p${options.page}/a${options.note}`;\n    } else {\n      urlPostfix = `#document/p${options.page}`;\n    }\n  }\n\n  iframe.style = style;\n  iframe.src = queryBuilder(`${process.env.APP_URL}documents/${id}-${slug}`, queryParams) + urlPostfix;\n  setupResizeEvent(iframe);\n\n  container.appendChild(iframe);\n}\n\nwindow.DV = {\n  load: function (url, options) {\n    const containerId = options['container'];\n    if (containerId != null) {\n      const container = document.querySelector(containerId);\n      if (container != null && container.children.length == 0) {\n        injectIframe(url, options, container);\n      }\n    }\n  }\n}\n","import { timeoutify } from '@/util/closure';\n\nexport function informSize(element, useScrollDimension = true) {\n  // Inform a parent window about an embed size\n  const update = () => {\n    window.parent.postMessage({\n      width: Math.max(useScrollDimension ? element.scrollWidth : 0, element.offsetWidth),\n      height: Math.max(useScrollDimension ? element.scrollHeight : 0, element.offsetHeight)\n    }, \"*\");\n  };\n\n  // Trigger event now and any time the window resizes\n  window.addEventListener('resize', timeoutify(update));\n  update();\n}\n\nexport function setupResizeEvent(iframe) {\n  window.addEventListener('message', (event) => {\n    if (event.source == iframe.contentWindow) {\n      const { width, height } = event.data;\n      if (width != null) {\n        iframe.width = width;\n      }\n      if (height != null) {\n        iframe.height = height;\n      }\n    }\n  });\n}\n","export function smoothify(fn) {\n  let timer = null;\n\n  return ((...args) => {\n    if (timer != null) {\n      cancelAnimationFrame(timer);\n      timer = null;\n    }\n\n    timer = requestAnimationFrame(() => {\n      timer = null;\n      fn(...args);\n    });\n  });\n}\n\nexport function timeoutify(fn, timeout = 100) {\n  let timer = null;\n\n  return ((...args) => {\n    if (timer != null) {\n      clearTimeout(timer);\n      timer = null;\n    }\n\n    timer = setTimeout(() => {\n      timer = null;\n      fn(...args);\n    }, timeout);\n  });\n}\n\nexport function ignoreFirst(closure) {\n  // Ignore first invocation of a function\n  let first = true;\n  return (...args) => {\n    if (first) {\n      first = false;\n    } else {\n      closure(...args);\n    }\n  }\n}\n","/**\n * Splits a URL into its base and query component.\n * @param {string} url The URL from which to extract parts.\n */\nexport function urlParts(url) {\n  const qIndex = url.indexOf(\"?\");\n  if (qIndex == -1) return [url, null];\n  return [url.substr(0, qIndex), url.substr(qIndex + 1)];\n}\n\n/**\n * Join a URL, normalizing for slashes in between\n * @param  {...string} parts URL fragments to join\n */\nexport function urlJoin(...parts) {\n  return parts.reduce((a, b) => {\n    if (a.endsWith('/')) {\n      a = a.substr(0, a.length - 1);\n    }\n    if (b.startsWith('/')) {\n      b = b.substr(1);\n    }\n    if (a == '') return b;\n    if (b == '') return a;\n    return [a, b].join('/');\n  }, '');\n}\n\n// Adapted from: https://stackoverflow.com/a/3855394\nfunction getQueryStringParamsFromQuery(query) {\n  if (query == null) return {};\n  return query.split(\"&\").reduce((params, param) => {\n    let [key, value] = param.split(\"=\");\n    params[key] = value ? decodeURIComponent(value.replace(/\\+/g, \" \")) : \"\";\n    return params;\n  }, {});\n}\n\n/**\n * Returns a map of query keys/values from a URL.\n * @param {string} url The URL from which to collect query params.\n */\nexport function getQueryStringParams(url) {\n  const [_, query] = urlParts(url);\n  return getQueryStringParamsFromQuery(query);\n}\n\nexport function urlsEqual(url1, url2) {\n  const [base1, query1] = urlParts(url1);\n  const [base2, query2] = urlParts(url2);\n\n  // Base URLs must match\n  if (base1 != base2) return false;\n\n  const qp1 = getQueryStringParamsFromQuery(query1);\n  const qp2 = getQueryStringParamsFromQuery(query2);\n\n  const keys1 = Object.keys(qp1);\n  const keys2 = Object.keys(qp2);\n\n  if (keys1.length != keys2.length) return false;\n\n  keys1.sort();\n  keys2.sort();\n\n  for (let i = 0; i < keys1.length; i++) {\n    const k1 = keys1[i];\n    const k2 = keys2[i];\n    if (k1 != k2) return false;\n    if (qp1[k1] != qp2[k2]) return false;\n  }\n  return true;\n}\n\nexport function currentUrl() {\n  return window.location.pathname + window.location.search;\n}\n\n/**\n * Constructs a URL with specified query parameters\n * @param {string} baseUrl The base URL on which to add query parameters\n * @param {Object} params A dictionary of key-value pairs for each query parameter\n * @param {boolean} cleanSlate If true, wipes existing query parameters\n */\nexport function queryBuilder(baseUrl, params, cleanSlate = false) {\n  if (baseUrl == null) baseUrl = currentUrl();\n  const [url, query] = urlParts(baseUrl);\n  const oldParams = cleanSlate ? {} : getQueryStringParamsFromQuery(query);\n\n  // Overwrite old params with new params\n  for (const prop in params) {\n    if (params.hasOwnProperty(prop)) {\n      oldParams[prop] = params[prop];\n    }\n  }\n\n  let result = \"\";\n  let prefix = \"?\";\n\n  for (const prop in oldParams) {\n    if (oldParams.hasOwnProperty(prop)) {\n      const key = prop;\n      const value = oldParams[key];\n\n      // Skip undefined query params\n      if (value == null) continue;\n\n      result += `${prefix}${key}=${encodeURIComponent(value)}`;\n      // Only the first prefix will be \"?\"\n      prefix = \"&\";\n    }\n  }\n\n  return `${url}${result}`;\n}\n\n// Return if a query parameter value is truthy\nexport function truthyParamValue(value) {\n  if (value == null) return false;\n  const normalized = value.trim().toLowerCase();\n  return normalized == \"1\" || normalized == \"true\" || normalized == \"yes\";\n}\n\n// Return if a query parameter value is explicitly falsy (and not just null)\nexport function falsyParamValue(value) {\n  if (value == null) return false;\n  const normalized = value.trim().toLowerCase();\n  return normalized == \"0\" || normalized == \"false\" || normalized == \"no\";\n}\n"],"sourceRoot":""}